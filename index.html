<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Model Race Track</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div id="raceTrack">
            <div class="lane"></div>
            <div class="lane"></div>
            <div class="lane"></div>
            <div class="lane"></div>
            <div id="winner"></div>
        </div>
        <div id="modelNames">
            <!-- Provider checkboxes and model selects will be dynamically added here -->
        </div>
    </div>
    <div id="controls">
        <div id="race-controls">
            <button id="startButton">Start Race</button>
            <button id="stopButton">Stop Race</button>
            <input type="number" id="finishLineInput" placeholder="Finish line distance" value="7000" min="1000" step="1000">
        </div>
        <div id="streamModeContainer">
            <input type="radio" id="streamModeDirect" name="streamMode" value="direct">
            <label for="streamModeDirect">Stream tokens Directly</label>
            <input type="radio" id="streamModeSave" name="streamMode" value="save" checked>
            <label for="streamModeSave">Stream and save tokens for all and then race</label>
        </div>
        <input type="text" id="promptInput" placeholder="Enter your prompt here">
    </div>

    <script src="groq.js"></script>
    <script>
        const raceTrack = document.getElementById('raceTrack');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const winnerDisplay = document.getElementById('winner');
        const streamModeDirect = document.getElementById('streamModeDirect');
        const streamModeSave = document.getElementById('streamModeSave');
        const providers = Object.keys(API_PROVIDERS);
        const cars = {};
        // const finishLine = 7000;
        const updateInterval = 100; // Update every 100ms
        let raceActive = false;
        let finishedProviders = new Set();
        const finishLineInput = document.getElementById('finishLineInput');
        let finishLine = parseInt(finishLineInput.value, 10); // Initialize with the default value

        finishLineInput.addEventListener('change', (event) => {
            finishLine = parseInt(event.target.value, 10);
            console.log(`Finish line distance updated to: ${finishLine}`);
        });

        const imageFiles = [ 'racing-car-296772_1920.png']; // Add all available image files here

        function updateCars() 
        {
            raceTrack.innerHTML = '<div class="lane"></div><div class="lane"></div><div class="lane"></div><div class="lane"></div><div id="winner"></div>';
            let activeIndex = 0;
            providers.forEach((provider, index) => {
                if (API_PROVIDERS[provider] && API_PROVIDERS[provider].active !== false) {
                    const car = document.createElement('div');
                    car.className = 'car';
                    const topPosition =  activeIndex * 100 + 25;
                    car.style.top = `${topPosition}px`;
                    console.log(`Car for ${provider} positioned at top: ${topPosition}px`);
                    const randomImage = imageFiles[Math.floor(Math.random() * imageFiles.length)];
                    car.innerHTML = `
                        <img src="images/${randomImage}" alt="${provider}">
                        <div class="car-info">
                            <div class="car-name">${API_PROVIDERS[provider].name}</div>
                            <div class="car-speed">0 t/s</div>
                        </div>
                    `;
                    raceTrack.appendChild(car);
                    cars[provider] = { element: car, position: 0, tokensPerSecond: 0, index: 0, outOfTokens: false };
                    activeIndex++;
                }
            });
        }

        async function updateCarPosition(provider) {
            if (cars[provider] && raceActive && !finishedProviders.has(provider) && !cars[provider].outOfTokens) {
                let tokensPerSecond;
                if (streamModeDirect.checked) {
                    tokensPerSecond = await updateTokensPerSecond(API_PROVIDERS[provider], getCurrentPrompt());
                } else {
                    const tokensPerSecondList = getTokensPerSecondList(provider);
                    if (tokensPerSecondList && cars[provider].index < tokensPerSecondList.length) {
                        tokensPerSecond = tokensPerSecondList[cars[provider].index];
                        cars[provider].index++;
                    } else {
                        // Provider has run out of tokens
                        finishProvider(provider, true);
                        return;
                    }
                }
                
                if (tokensPerSecond) {
                    cars[provider].tokensPerSecond = tokensPerSecond;
                    cars[provider].element.querySelector('.car-speed').textContent = `${tokensPerSecond.toFixed(1)} t/s`;
                    if (!finishedProviders.has(provider)) {
                        cars[provider].element.style.transform = `rotate(${Math.random() * 10 - 5}deg)`; // Add a slight rotation for effect
                    }
                }
                
                setTimeout(() => updateCarPosition(provider), updateInterval);
            }
        }

        function moveCards() {
            if (raceActive) {
                const trackWidth = raceTrack.offsetWidth;
                for (const [provider, car] of Object.entries(cars)) {
                    if (car.tokensPerSecond && !finishedProviders.has(provider) && !car.outOfTokens) {
                        car.position += (car.tokensPerSecond / 10);
                        const scaledPosition = (car.position / finishLine) * (trackWidth - car.element.offsetWidth);
                        car.element.style.left = `${Math.min(scaledPosition, trackWidth - car.element.offsetWidth)}px`;
                        
                        if (car.position > finishLine) {
                            console.log(`${API_PROVIDERS[provider].name} finished the race!`);
                            finishProvider(provider);
                        }
                    }
                }
                requestAnimationFrame(moveCards);
            }
        }

        async function startRace() {
            updateCars();
            Object.values(cars).forEach(car => {
                car.element.style.left = '0px';
                car.position = 0;
                car.tokensPerSecond = 0;
                car.index = 0;
                car.outOfTokens = false;
            });
            winnerDisplay.style.display = 'none';
            raceActive = true;
            finishedProviders.clear();

            // Use the current prompt when starting the race
            const currentPrompt = getCurrentPrompt();
            console.log(`Starting race with prompt: ${currentPrompt}`);
            if (streamModeSave.checked) {
                await runSimultaneousComparison();
            }

            for (const provider of providers) {
                if (API_PROVIDERS[provider] && API_PROVIDERS[provider].active !== false) {
                    updateCarPosition(provider);
                }
            }
            moveCards();
        }
        function finishProvider(provider, outOfTokens = false) 
        {
            console.log(`finishProvider called for ${provider}. Out of tokens: ${outOfTokens}`);
            
            // Check if the provider is active before adding to finishedProviders
            if (API_PROVIDERS[provider] && API_PROVIDERS[provider].active !== false && !outOfTokens) {
                finishedProviders.add(provider);
                console.log(`Current finishedProviders: ${Array.from(finishedProviders)}`);
            } else {
                console.log(`Provider ${provider} is disabled, not found, or out of tokens. Not adding to finishedProviders.`);
            }

            if (cars[provider]) {
                console.log(`Stopping animation for ${provider}'s car`);
                cars[provider].element.style.animation = 'none'; // Stop the jiggling animation
                
                if (outOfTokens) {
                    console.log(`${provider} is out of tokens`);
                    cars[provider].element.querySelector('.car-speed').textContent = 'Out of tokens';
                    cars[provider].outOfTokens = true;
                }
            } else {
                console.warn(`Car not found for provider: ${provider}`);
            }

            // Check if this is the first provider to finish and announce the winner
            if (finishedProviders.size === 1 && API_PROVIDERS[provider] && !outOfTokens) 
            {
                console.log(`First provider to finish: ${provider}`);
                const winnerDisplay = document.getElementById('winner');
                winnerDisplay.textContent = `${API_PROVIDERS[provider].name} wins!`;
                winnerDisplay.style.display = 'block';
                winnerDisplay.style.position = 'absolute';
                winnerDisplay.style.top = '10px';
                winnerDisplay.style.left = '50%';
                winnerDisplay.style.transform = 'translateX(-50%)';
                winnerDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                winnerDisplay.style.color = '#FFD700';
                winnerDisplay.style.padding = '15px';
                winnerDisplay.style.border = '3px solid #FFD700';
                winnerDisplay.style.borderRadius = '10px';
                winnerDisplay.style.fontSize = '24px';
                winnerDisplay.style.fontWeight = 'bold';
                winnerDisplay.style.textShadow = '2px 2px 4px #000000';
                winnerDisplay.style.boxShadow = '0 0 20px #FFD700';
                winnerDisplay.style.zIndex = '1000';
                winnerDisplay.style.animation = 'winnerPulse 1.5s infinite';

                // Add keyframe animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes winnerPulse {
                        0% { transform: translateX(-50%) scale(1); }
                        50% { transform: translateX(-50%) scale(1.1); }
                        100% { transform: translateX(-50%) scale(1); }
                    }
                `;
                document.head.appendChild(style);

                console.log(`Winner announced: ${API_PROVIDERS[provider].name}`);
            } else 
            {
                console.log(`Not announcing winner. Finished providers: ${finishedProviders.size}`);
            }
            
            const activeProviders = providers.filter(p => API_PROVIDERS[p] && API_PROVIDERS[p].active !== false);
            const finishedActiveProviders = Array.from(finishedProviders).filter(p => activeProviders.includes(p));
            if (finishedActiveProviders.length === activeProviders.length) {
                console.log('All active providers have finished. Ending race.');
                endRace();
            } else {
                console.log(`Race continues. Finished: ${finishedActiveProviders.length}/${activeProviders.length}`);
            }
        }

        function endRace() {
            raceActive = false;
        }

        function stopRace() {
            location.reload(); // Reload the page
        }

        startButton.addEventListener('click', startRace);
        stopButton.addEventListener('click', stopRace);

        window.addEventListener('resize', () => {
            if (!raceActive) {
                Object.values(cars).forEach(car => {
                    car.element.style.left = '0px';
                    car.position = 0;
                });
            }
        });

        function updateProviderNames() {
            const modelNamesContainer = document.getElementById('modelNames');
            modelNamesContainer.innerHTML = ''; // Clear existing names

            Object.keys(API_PROVIDERS).forEach(providerKey => {
                const provider = API_PROVIDERS[providerKey];
                const providerDiv = document.createElement('div');
                providerDiv.className = 'model-name';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = providerKey;
                checkbox.name = 'provider';
                checkbox.value = providerKey;
                checkbox.checked = true;

                checkbox.addEventListener('change', (event) => {
                    console.log(`Checkbox for ${providerKey} changed. Checked: ${event.target.checked}`);
                    updateActiveProviders();
                    updateCars();
                });

                const label = document.createElement('label');
                label.htmlFor = providerKey;
                label.textContent = provider.name;

                const modelSelect = document.createElement('select');
                modelSelect.id = `${providerKey}-model`;
                modelSelect.name = `${providerKey}-model`;
                provider.models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    if (model === provider.selectedModel) {
                        option.selected = true;
                    }
                    modelSelect.appendChild(option);
                });

                modelSelect.addEventListener('change', (event) => {
                    provider.selectedModel = event.target.value;
                    console.log(`Selected model for ${provider.name}: ${provider.selectedModel}`);
                });

                providerDiv.appendChild(checkbox);
                providerDiv.appendChild(label);
                providerDiv.appendChild(modelSelect);
                modelNamesContainer.appendChild(providerDiv);
            });
        }

        // Add this function to handle the prompt input
        function handlePromptInput() {
            const promptInput = document.getElementById('promptInput');
            promptInput.addEventListener('change', (event) => {
                const prompt = event.target.value;
                console.log('New prompt:', prompt);
                // You can add logic here to use the new prompt in your race
            });
        }

        // Call updateProviderNames when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            updateProviderNames();
            updateActiveProviders();
            handlePromptInput();
            updateCars();
        });
    </script>
</body>
</html>