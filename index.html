<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VectorVelocity</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="heading-container">
        <h1>Vector Velocity</h1>
        <p>Compare the speed of different AI models in a fun and interactive way.</p>
        <p>Select your favorite model and watch it race to the finish line.</p>
        <p>The race is run using the same prompt for all models, and the speed is measured in (~tokens ) words per second (WPS).</p>
    </div>
    <div class="container">
        <div id="raceTrack">
            <!-- Will be generated by update cars -->
        </div>
        <div id="modelNames">
            <!-- Provider checkboxes and model selects will be dynamically added here -->
            <div id="race-controls">
                <div class="finish-line-control">
                    <label for="finishLineInput" style="font-family: 'Montserrat', sans-serif; font-weight: 600;">FINISH DISTANCE (scaled Token/s):</label>
                    <br><br>
                    <input type="number" id="finishLineInput" placeholder="Finish line distance" value="6000" min="1000" step="1000" style="font-family: 'Roboto', sans-serif;">
                    <div id="streamModeContainer" style="font-family: 'Open Sans', sans-serif;">
                        <h3 style="font-family: 'Poppins', sans-serif; font-weight: 700;">STREAM MODE</h3>
                        <div>
                            <input type="radio" id="streamModeDirect" name="streamMode" value="direct">
                            <label for="streamModeDirect" style="font-family: 'Lato', sans-serif;">INSTANT: Generate and race simultaneously</label>
                        </div>
                        <div>
                            <input type="radio" id="streamModeSave" name="streamMode" value="save" checked>
                            <label for="streamModeSave" style="font-family: 'Lato', sans-serif;">STORE AND RACE: Generate content first, then race</label>
                        </div>
                    </div>
                </div>
            </div>
            <div id="providers_models" style="font-family: 'Roboto', sans-serif;">
                
            </div>
        </div>
        <div id="promptInputContainer">
            <input type="text" id="promptInput" placeholder="Enter your prompt here">
            <div id="raceButtons">
                <button id="startButton">Start Race</button>
                <button id="stopButton">Stop Race</button>
            </div>
        </div>
    </div>

    <script src="groq.js"></script>
    <script>
        const raceTrack = document.getElementById('raceTrack');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const winnerDisplay = document.getElementById('winner');
        const streamModeDirect = document.getElementById('streamModeDirect');
        const streamModeSave = document.getElementById('streamModeSave');
        const providers = Object.keys(API_PROVIDERS);
        const cars = {};
        // const finishLine = 7000;
        const updateInterval = 100; // Update every 100ms
        let raceActive = false;
        let finishedProviders = new Set();
        const finishLineInput = document.getElementById('finishLineInput');
        let finishLine = parseInt(finishLineInput.value, 10); // Initialize with the default value

        finishLineInput.addEventListener('change', (event) => {
            finishLine = parseInt(event.target.value, 10);
            console.log(`Finish line distance updated to: ${finishLine}`);
        });
        const imageFiles = [ 'racing-car-296772_1920.png']; // Add all available image files here

        function updateCars() 
        {
            raceTrack.innerHTML = ''; // Clear existing lanes
            console.log('Providers:', providers);
            console.log('API_PROVIDERS:', API_PROVIDERS);
            const activeCars = providers.filter(provider => {
                console.log(`Checking provider: ${provider}`);
                console.log(`API_PROVIDERS[${provider}]:`, API_PROVIDERS[provider]);
                console.log(`API_PROVIDERS[${provider}].active:`, API_PROVIDERS[provider] ? API_PROVIDERS[provider].active : 'undefined');
                return API_PROVIDERS[provider] && API_PROVIDERS[provider].active !== false;
            });
            console.log('Active cars:', activeCars);
            const laneHeight = 100 / activeCars.length; // Calculate lane height based on number of active cars

            activeCars.forEach((provider, index) => {
                console.log(`Creating car for provider: ${provider}`);
                const lane = document.createElement('div');
                lane.className = 'lane';
                lane.style.top = `${index * laneHeight}%`;
                lane.style.height = `${laneHeight}%`;
                raceTrack.appendChild(lane);

                const car = document.createElement('div');
                car.className = 'car';
                const topPosition = (index / (activeCars.length)) * 100 + 7.5; // Evenly space cars from 0 to 100
                car.style.top = `${topPosition}%`;
                const randomImage = imageFiles[Math.floor(Math.random() * imageFiles.length)];
                car.innerHTML = `
                    <img src="images/${randomImage}" alt="${provider}">
                    <div class="car-info">
                        <div class="car-name">${API_PROVIDERS[provider].name}</div>
                        <div class="car-speed">0 t/s</div>
                    </div>
                `;
                raceTrack.appendChild(car);
                cars[provider] = { element: car, position: 0, tokensPerSecond: 0, index: 0, outOfTokens: false, lanePosition: topPosition };

                // Debug: Log car name, image path, and lane position
                console.log(`Car created for ${provider}:`);
                console.log(`  Name: ${API_PROVIDERS[provider].name}`);
                console.log(`  Image: images/${randomImage}`);
                console.log(`  Lane position: ${topPosition}%`);
            });

            raceTrack.appendChild(document.createElement('div')).id = 'winner';
            console.log('Final cars object:', cars);

            // Debug: Log the number of active cars and their providers
            console.log('Number of active cars:', activeCars.length);
            console.log('Active providers:', activeCars);
            console.log('All providers:', providers);
            console.log('API_PROVIDERS:', API_PROVIDERS);
            logCarLanePositions();
        }

        function logCarLanePositions() {
            console.log('Current car lane positions:');
            for (const [provider, car] of Object.entries(cars)) {
                console.log(`${API_PROVIDERS[provider].name}: ${car.lanePosition}%`);
            }
        }

        async function updateCarPosition(provider) {
            if (cars[provider] && raceActive && !finishedProviders.has(provider) && !cars[provider].outOfTokens) {
                let tokensPerSecond;
                if (streamModeDirect.checked) {
                    tokensPerSecond = await updateTokensPerSecond(API_PROVIDERS[provider], getCurrentPrompt());
                } else {
                    const tokensPerSecondList = getTokensPerSecondList(provider);
                    if (tokensPerSecondList && cars[provider].index < tokensPerSecondList.length) {
                        tokensPerSecond = tokensPerSecondList[cars[provider].index];
                        cars[provider].index++;
                    } else {
                        // Provider has run out of tokens
                        finishProvider(provider, true);
                        return;
                    }
                }
                
                if (tokensPerSecond) {
                    cars[provider].tokensPerSecond = tokensPerSecond;
                    cars[provider].element.querySelector('.car-speed').textContent = `${tokensPerSecond.toFixed(1)} t/s`;
                    if (!finishedProviders.has(provider)) {
                        cars[provider].element.style.transform = `rotate(${Math.random() * 10 - 5}deg)`; // Add a slight rotation for effect
                    }
                }
                
                setTimeout(() => updateCarPosition(provider), updateInterval);
            }
        }

        function moveCards() {
            if (raceActive) {
                const trackWidth = raceTrack.offsetWidth;
                for (const [provider, car] of Object.entries(cars)) {
                    if (car.tokensPerSecond && !finishedProviders.has(provider) && !car.outOfTokens) {
                        car.position += (car.tokensPerSecond / 10);
                        const scaledPosition = (car.position / finishLine) * (trackWidth - car.element.offsetWidth);
                        car.element.style.left = `${Math.min(scaledPosition, trackWidth - car.element.offsetWidth)}px`;
                        
                        if (car.position > finishLine) {
                            console.log(`${API_PROVIDERS[provider].name} finished the race!`);
                            finishProvider(provider);
                        }
                    }
                }
                requestAnimationFrame(moveCards);
            }
        }

        async function startRace() {
            updateCars();
            Object.values(cars).forEach(car => {
                car.element.style.left = '0px';
                car.position = 0;
                car.tokensPerSecond = 0;
                car.index = 0;
                car.outOfTokens = false;
            });
            // winnerDisplay.style.display = 'none';
            raceActive = true;
            finishedProviders.clear();

            // Use the current prompt when starting the race
            const currentPrompt = getCurrentPrompt();
            console.log(`Starting race with prompt: ${currentPrompt}`);
            if (streamModeSave.checked) {
                await runSimultaneousComparison();
            }

            for (const provider of providers) {
                if (API_PROVIDERS[provider] && API_PROVIDERS[provider].active !== false) {
                    updateCarPosition(provider);
                }
            }
            moveCards();
        }
        function finishProvider(provider, outOfTokens = false) 
        {
            console.log(`finishProvider called for ${provider}. Out of tokens: ${outOfTokens}`);
            
            // Check if the provider is active before adding to finishedProviders
            if (API_PROVIDERS[provider] && API_PROVIDERS[provider].active !== false && !outOfTokens) {
                finishedProviders.add(provider);
                console.log(`Current finishedProviders: ${Array.from(finishedProviders)}`);
            } else {
                console.log(`Provider ${provider} is disabled, not found, or out of tokens. Not adding to finishedProviders.`);
            }

            if (cars[provider]) {
                console.log(`Stopping animation for ${provider}'s car`);
                cars[provider].element.style.animation = 'none'; // Stop the jiggling animation
                
                if (outOfTokens) {
                    console.log(`${provider} is out of tokens`);
                    cars[provider].element.querySelector('.car-speed').textContent = 'Out of tokens';
                    cars[provider].outOfTokens = true;
                }
            } else {
                console.warn(`Car not found for provider: ${provider}`);
            }

            // Check if this is the first provider to finish and announce the winner
            if (finishedProviders.size === 1 && API_PROVIDERS[provider] && !outOfTokens) 
            {
                console.log(`First provider to finish: ${provider}`);
                const winnerDisplay = document.getElementById('winner');
                winnerDisplay.textContent = `${API_PROVIDERS[provider].name} wins!`;
                winnerDisplay.style.display = 'block';
                winnerDisplay.style.position = 'absolute';
                winnerDisplay.style.top = '10px';
                winnerDisplay.style.left = '50%';
                winnerDisplay.style.transform = 'translateX(-50%)';
                winnerDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                winnerDisplay.style.color = '#FFD700';
                winnerDisplay.style.padding = '15px';
                winnerDisplay.style.border = '3px solid #FFD700';
                winnerDisplay.style.borderRadius = '10px';
                winnerDisplay.style.fontSize = '24px';
                winnerDisplay.style.fontWeight = 'bold';
                winnerDisplay.style.textShadow = '2px 2px 4px #000000';
                winnerDisplay.style.boxShadow = '0 0 20px #FFD700';
                winnerDisplay.style.zIndex = '1000';
                winnerDisplay.style.animation = 'winnerPulse 1.5s infinite';

                // Add keyframe animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes winnerPulse {
                        0% { transform: translateX(-50%) scale(1); }
                        50% { transform: translateX(-50%) scale(1.1); }
                        100% { transform: translateX(-50%) scale(1); }
                    }
                `;
                document.head.appendChild(style);

                console.log(`Winner announced: ${API_PROVIDERS[provider].name}`);
            } else 
            {
                console.log(`Not announcing winner. Finished providers: ${finishedProviders.size}`);
            }
            
            const activeProviders = providers.filter(p => API_PROVIDERS[p] && API_PROVIDERS[p].active !== false);
            const finishedActiveProviders = Array.from(finishedProviders).filter(p => activeProviders.includes(p));
            if (finishedActiveProviders.length === activeProviders.length) {
                console.log('All active providers have finished. Ending race.');
                endRace();
            } else {
                console.log(`Race continues. Finished: ${finishedActiveProviders.length}/${activeProviders.length}`);
            }
        }

        function endRace() {
            raceActive = false;
        }

        function stopRace() {
            location.reload(); // Reload the page
        }

        startButton.addEventListener('click', startRace);
        stopButton.addEventListener('click', stopRace);

        window.addEventListener('resize', () => {
            if (!raceActive) {
                Object.values(cars).forEach(car => {
                    car.element.style.left = '0px';
                    car.position = 0;
                });
            }
        });
        function updateProviderNames() {
            const modelNamesContainer = document.getElementById('providers_models');
            modelNamesContainer.style.display = 'flex';
            modelNamesContainer.style.flexDirection = 'row';
            modelNamesContainer.style.flexWrap = 'wrap';
            modelNamesContainer.style.gap = '10px';

            // Find the maximum label width
            let maxLabelWidth = 0;
            Object.keys(API_PROVIDERS).forEach(providerKey => {
                const provider = API_PROVIDERS[providerKey];
                const tempLabel = document.createElement('label');
                tempLabel.textContent = provider.name;
                document.body.appendChild(tempLabel);
                const labelWidth = tempLabel.offsetWidth;
                document.body.removeChild(tempLabel);
                maxLabelWidth = Math.max(maxLabelWidth, labelWidth);
            });

            Object.keys(API_PROVIDERS).forEach(providerKey => {
                const provider = API_PROVIDERS[providerKey];
                const providerDiv = document.createElement('div');
                providerDiv.className = 'model-name';
                providerDiv.style.display = 'grid';
                
                providerDiv.style.gridTemplateColumns = `auto ${100}px auto`;
                providerDiv.style.alignItems = 'center';
                providerDiv.style.gap = '10px';
                providerDiv.style.marginRight = '20px';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = providerKey;
                checkbox.name = 'provider';
                checkbox.value = providerKey;
                checkbox.checked = true;

                checkbox.addEventListener('change', (event) => {
                    console.log(`Checkbox for ${providerKey} changed. Checked: ${event.target.checked}`);
                    updateActiveProviders();
                    updateCars();
                });

                const label = document.createElement('label');
                label.htmlFor = providerKey;
                label.textContent = provider.name;
                label.style.whiteSpace = 'nowrap';
                label.style.overflow = 'hidden';
                label.style.textOverflow = 'ellipsis';

                const modelSelect = document.createElement('select');
                modelSelect.id = `${providerKey}-model`;
                modelSelect.name = `${providerKey}-model`;
                provider.models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    if (model === provider.selectedModel) {
                        option.selected = true;
                    }
                    modelSelect.appendChild(option);
                });

                modelSelect.addEventListener('change', (event) => {
                    provider.selectedModel = event.target.value;
                    console.log(`Selected model for ${provider.name}: ${provider.selectedModel}`);
                });

                providerDiv.appendChild(checkbox);
                providerDiv.appendChild(label);
                providerDiv.appendChild(modelSelect);
                modelNamesContainer.appendChild(providerDiv);
            });
        }

        // Add this function to handle the prompt input
        function handlePromptInput() {
            const promptInput = document.getElementById('promptInput');
            promptInput.addEventListener('change', (event) => {
                const prompt = event.target.value;
                console.log('New prompt:', prompt);
            });
        }

        // Call updateProviderNames when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            updateProviderNames();
            updateActiveProviders();
            handlePromptInput();
            updateCars();
        });
    </script>
</body>
</html>